/**
 * Data loading utilities for OSRS Farming data
 * 
 * This module provides functions to load and access the static farming data
 * generated by the fetch script. Since the JSON files may not exist during
 * TypeScript compilation, we'll create placeholder data and provide a way
 * to update it at runtime.
 */

import type { 
  FarmingDatabase, 
  Crop, 
  FarmingPatch, 
  DependencyRelationship,
  YieldCalculation 
} from '../types/farming';

// Placeholder farming database (will be populated by data loader)
let farmingDatabase: FarmingDatabase = {
  crops: {
    metadata: {
      lastUpdated: '',
      version: '1.0.0',
      source: 'Placeholder'
    },
    allotments: [],
    flowers: []
  },
  dependencies: {
    metadata: {
      lastUpdated: '',
      description: 'Placeholder'
    },
    relationships: {}
  },
  patches: {
    metadata: {
      lastUpdated: '',
      description: 'Placeholder'
    },
    locations: []
  },
  yieldTables: {
    metadata: {
      description: 'Placeholder',
      lastUpdated: ''
    },
    calculations: {
      baseFormula: '',
      compostBonuses: {},
      levelBonuses: { description: '' }
    },
    crops: {}
  },
  cache: {
    itemMappings: [],
    seedPrices: {},
    lastFetch: ''
  }
};

/**
 * Initialize farming database from JSON files
 * Call this after the fetch script has generated the data files
 */
export async function initializeFarmingData(): Promise<void> {
  try {
    // In a real implementation, these would be fetched from the generated files
    // For now, we'll use dynamic imports when the files exist
    const fs = await import('fs/promises');
    const path = await import('path');
    
    const dataDir = path.join(process.cwd(), 'src/data');
    
    const [
      cropsJson,
      dependenciesJson,
      patchesJson,
      yieldTablesJson,
      wikiCacheJson
    ] = await Promise.all([
      fs.readFile(path.join(dataDir, 'crops.json'), 'utf-8'),
      fs.readFile(path.join(dataDir, 'dependencies.json'), 'utf-8'),
      fs.readFile(path.join(dataDir, 'patches.json'), 'utf-8'),
      fs.readFile(path.join(dataDir, 'yield-tables.json'), 'utf-8'),
      fs.readFile(path.join(dataDir, 'wiki-cache.json'), 'utf-8')
    ]);

    farmingDatabase = {
      crops: JSON.parse(cropsJson),
      dependencies: JSON.parse(dependenciesJson),
      patches: JSON.parse(patchesJson),
      yieldTables: JSON.parse(yieldTablesJson),
      cache: JSON.parse(wikiCacheJson)
    };
  } catch (error) {
    console.warn(`Failed to load farming database: ${error}. Make sure to run the fetch script first.`);
    // Continue with placeholder data
  }
}

/**
 * Get all supported allotment crops
 */
export function getAllotmentCrops(): Crop[] {
  return farmingDatabase.crops.allotments;
}

/**
 * Get all supported flower crops
 */
export function getFlowerCrops(): Crop[] {
  return farmingDatabase.crops.flowers;
}

/**
 * Get all crops (allotments + flowers)
 */
export function getAllCrops(): Crop[] {
  return [...getAllotmentCrops(), ...getFlowerCrops()];
}

/**
 * Get crop by ID
 */
export function getCropById(id: string): Crop | undefined {
  return getAllCrops().find(crop => crop.id === id);
}

/**
 * Get crops by type
 */
export function getCropsByType(type: 'allotment' | 'flower'): Crop[] {
  return type === 'allotment' ? getAllotmentCrops() : getFlowerCrops();
}

/**
 * Get all farming patches
 */
export function getAllPatches(): FarmingPatch[] {
  return farmingDatabase.patches.locations;
}

/**
 * Get patches by type
 */
export function getPatchesByType(type: 'allotment' | 'flower'): FarmingPatch[] {
  return getAllPatches().filter(patch => patch.type === type);
}

/**
 * Get patch by ID
 */
export function getPatchById(id: string): FarmingPatch | undefined {
  return getAllPatches().find(patch => patch.id === id);
}

/**
 * Get patches by location
 */
export function getPatchesByLocation(location: string): FarmingPatch[] {
  return getAllPatches().filter(patch => patch.location === location);
}

/**
 * Get dependency relationship for a crop
 */
export function getCropDependencies(cropId: string): DependencyRelationship | undefined {
  return farmingDatabase.dependencies.relationships[cropId];
}

/**
 * Get crops that support (can pay for) a given crop
 */
export function getCropsSupporting(cropId: string): string[] {
  const supporters: string[] = [];
  
  Object.entries(farmingDatabase.dependencies.relationships).forEach(([supporterCropId, deps]) => {
    if (deps.supports.includes(cropId)) {
      supporters.push(supporterCropId);
    }
  });
  
  return supporters;
}

/**
 * Get yield calculation for a crop
 */
export function getCropYield(cropId: string): YieldCalculation | undefined {
  return farmingDatabase.yieldTables.crops[cropId];
}

/**
 * Get current seed price for a crop (if available)
 */
export function getSeedPrice(cropId: string): { high: number; low: number } | undefined {
  const crop = getCropById(cropId);
  if (!crop) return undefined;
  
  return farmingDatabase.cache.seedPrices[crop.seedId.toString()];
}

/**
 * Get data freshness information
 */
export function getDataFreshness() {
  return {
    crops: farmingDatabase.crops.metadata.lastUpdated,
    dependencies: farmingDatabase.dependencies.metadata.lastUpdated,
    patches: farmingDatabase.patches.metadata.lastUpdated,
    yieldTables: farmingDatabase.yieldTables.metadata.lastUpdated,
    cache: farmingDatabase.cache.lastFetch
  };
}

/**
 * Validate that required data is available
 */
export function validateDataIntegrity(): { valid: boolean; errors: string[] } {
  const errors: string[] = [];
  
  // Check that we have crops
  if (getAllCrops().length === 0) {
    errors.push('No crops data available');
  }
  
  // Check that we have patches
  if (getAllPatches().length === 0) {
    errors.push('No patches data available');
  }
  
  // Check that dependencies are consistent
  const allCropIds = new Set(getAllCrops().map(crop => crop.id));
  Object.entries(farmingDatabase.dependencies.relationships).forEach(([cropId, deps]) => {
    if (!allCropIds.has(cropId)) {
      errors.push(`Dependency references unknown crop: ${cropId}`);
    }
    
    deps.directDependencies.forEach(depId => {
      if (!allCropIds.has(depId) && depId !== 'potato') { // Allow potato as it has no dependencies
        errors.push(`Crop ${cropId} depends on unknown crop: ${depId}`);
      }
    });
  });
  
  return {
    valid: errors.length === 0,
    errors
  };
}

/**
 * Export database for advanced use cases
 */
export { farmingDatabase as database };

/**
 * Export types for external use
 */
export type { Crop, FarmingPatch, DependencyRelationship, YieldCalculation };
